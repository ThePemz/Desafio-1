#include <Adafruit_LiquidCrystal.h>  // Biblioteca para la pantalla LCD

// Pines para la pantalla LCD
Adafruit_LiquidCrystal lcd(0);

// Pines para los pulsadores
const int pinStart = 2;     // Pulsador para iniciar la adquisición
const int pinInfo = 4;      // Pulsador para solicitar información

// Variables para gestionar los estados
bool acquiring = false;  // Indica si está en proceso de adquisición
bool processing = false; // Indica si está en proceso de procesamiento

// Variables para los datos de la señal
int* signalData;  // Puntero al array de datos de la señal
long numSamples = 0;        // Contador de muestras
int arraySize = 10;       // Tamaño inicial del array dinámico

// Variables para la frecuencia y amplitud
unsigned long lastTime = 0;
unsigned long signalPeriod = 0;
float frequency = 0.0;
float amplitude = 0.0;

// Variables para el debounce
unsigned long lastButtonPressTime = 0;  // Tiempo de la última pulsación
unsigned long debounceDelay = 50;       // Tiempo de debounce para evitar múltiples lecturas

// Variables para gestionar tiempos con millis
unsigned long processingEndTime = 0;    // Tiempo en que debe finalizar el procesamiento

// Umbrales para la identificación de forma de onda
const int thresholdSin = 30;     // Tolerancia para identificar señal senoidal
const int thresholdSquare = 100; // Tolerancia para identificar señal cuadrada

int minSignal = 1023;
int maxSignal = 0;
float sum = 0;

// Setup inicial
void setup() {
  Serial.begin(12000);
  pinMode(pinStart, INPUT);
  pinMode(pinInfo, INPUT);
  
  lcd.begin(16, 2);  // Iniciar la pantalla LCD
  lcd.print("Informa2 S.A.S");
  delay(2000);
  lcd.clear();
  lcd.print("Ready to Start");
  delay(1000);
  
  lcd.clear();
  // Asignar memoria dinámica para el array de señal
  signalData = new int[arraySize];
}

// Loop principal
void loop() {
  unsigned long currentTime = millis();  // Obtener el tiempo actual

  bool stateStart = digitalRead(pinStart);
  bool stateInfo = digitalRead(pinInfo);  
  
  // Verificación del botón de inicio con debounce
  if (stateStart && (currentTime - lastButtonPressTime > debounceDelay)) {
    lastButtonPressTime = currentTime;  // Actualiza el tiempo de pulsación
    if (!acquiring && !processing) {
      lcd.clear();
      lcd.print("Acquiring...");
      acquiring = true;
      resetData();  // Reiniciar datos anteriores
    }
  }

  // Verificación del botón de información con debounce
  if (stateInfo && (currentTime - lastButtonPressTime > debounceDelay)) {
    lastButtonPressTime = currentTime;  // Actualiza el tiempo de pulsación
    if (acquiring) {
      acquiring = false;  // Pausar adquisición
      processing = true;  // Iniciar procesamiento
      lcd.clear();
      lcd.print("Processing...");
      displaySignalInfo();  // Mostrar la información de la señal
      processingEndTime = currentTime + 3000;  // Procesar durante 3 segundos
    }
  }

  // Si está en adquisición
  if (acquiring) {
    int signalValue = analogRead(A0);  // Leer señal analógica
    processSignal(signalValue);        // Procesar la señal
    calculateFrequency(signalValue);   // Calcular la frecuencia de la señal
  }

  // Manejar el final del procesamiento sin delay
  if (processing && currentTime >= processingEndTime) {
    processing = false;
    lcd.clear();
    lcd.print("Resuming...");
    delay(1000);
    lcd.clear();
    acquiring = true;  // Reanudar adquisición
  }
}

// Función para procesar la señal y almacenar en el array dinámico
void processSignal(int value) {
  // Si el número de muestras supera el tamaño del array, redimensionarlo
  if (numSamples >= arraySize) {
    resizeArray();
  }
  
  signalData[numSamples] = value;  // Guardar valor de la señal en el array
  numSamples+=1;
}

// Función para calcular la frecuencia de la señal
void calculateFrequency(int signalValue) {
  if (signalValue > (getMinSignal(signalValue) + getMaxSignal(signalValue)) / 2) {
    unsigned long currentTime = millis();
    signalPeriod = currentTime - lastTime;
    if (signalPeriod > 0) {
      frequency = 1000.0 / signalPeriod;  // Frecuencia en Hz
    }
    lastTime = currentTime;
  }
  
  // Calcular amplitud en Voltios (basado en el valor ADC)
  amplitude = (getMaxSignal(signalValue) - getMinSignal(signalValue)) * (5.0 / 1023.0);  // Amplitud en voltios
}

// Función para mostrar la información de la señal
void displaySignalInfo() {
  lcd.clear();
  
  lcd.setCursor(0, 0);
  lcd.print("Min: ");
  lcd.print(minSignal);
  
  lcd.setCursor(0, 1);
  lcd.print("Max: ");
  lcd.print(maxSignal);
  delay(2000);
  
  lcd.clear();
  lcd.print("Avg: ");
  lcd.print(sum/numSamples);
  delay(2000);
  
  lcd.clear();
  lcd.print("Freq: ");
  lcd.print(frequency);
  lcd.print(" Hz");
  delay(2000);
  
  lcd.clear();
  lcd.print("Amp: ");
  lcd.print(amplitude);
  lcd.print(" V");
  delay(2000);
}

// Función para obtener el valor mínimo de la señal
int getMinSignal(int value) {
  if (value < minSignal) {
    minSignal = value;
  }
  return minSignal;
}

// Función para obtener el valor máximo de la señal
int getMaxSignal(int value) {
  if (value > maxSignal) {
    maxSignal = value;
  }
  return maxSignal;
}

// Función para obtener el promedio de la señal
float getAverageSignal(int value) {
  sum += value;
  return sum / numSamples;
}


// Función para redimensionar el array dinámico
void resizeArray() {
  arraySize *= 2;  // Doblar el tamaño del array
  int* newArray = new int[arraySize];  // Crear nuevo array más grande
  
  // Copiar datos del array antiguo al nuevo
  for (long i = 0; i < numSamples; i++) {
    newArray[i] = signalData[i];
  }
  
  // Liberar la memoria antigua
  delete[] signalData;
  
  // Asignar el nuevo array al puntero original
  signalData = newArray;
}

// Función para reiniciar los datos de la señal
void resetData() {
  numSamples = 0;
  lastTime = 0;
  frequency = 0;
  amplitude = 0;
}

// Liberar la memoria dinámica cuando se termina
void freeMemory() {
  delete[] signalData;
}